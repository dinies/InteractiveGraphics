    <!DOCTYPE html>
    <html>
    <head>
<style>
.button {
  display: inline-block;
  border-radius: 2px;
  background-color: #0066ff;
  border: none;
  color: #FFFFFF;
  text-align: center;
  font-size: 10px;
  padding: 6px;
  width: 80px;
  transition: all 0.1s;
  cursor: pointer;
  margin: 1px;
}

.button span {
  cursor: pointer;
  display: inline-block;
  position: relative;
  transition: 0.5s;
}

.button span:after {
  content: '\00bb';
  position: absolute;
  opacity: 0;
  top: 0;
  right: -20px;
  transition: 0.5s;
}

.button:hover span {
  padding-right: 25px;
}

.button:hover span:after {
  opacity: 1;
  right: 0;
}

.switch {
  position: relative;
  display: inline-block;
  width: 60px;
  height: 34px;
}

.switch input {display:none;}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  -webkit-transition: .4s;
  transition: .4s;
}

.slider:before {
  position: absolute;
  content: "";
  height: 26px;
  width: 26px;
  left: 4px;
  bottom: 4px;
  background-color: white;
  -webkit-transition: .4s;
  transition: .4s;
}

input:checked + .slider {
  background-color: #2196F3;
}

input:focus + .slider {
  box-shadow: 0 0 1px #2196F3;
}

input:checked + .slider:before {
  -webkit-transform: translateX(26px);
  -ms-transform: translateX(26px);
  transform: translateX(26px);
}

/* Rounded sliders */
.slider.round {
  border-radius: 34px;
}

.slider.round:before {
  border-radius: 50%;
}


</style>
</head>

 
    <button class="button" style="vertical-align:middle" id = "ButtonX"><span>Rotate X</span></button>
    <button class="button" style="vertical-align:middle" id = "ButtonY"><span>Rotate Y</span></button>
    <button class="button" style="vertical-align:middle" id = "ButtonZ"><span>Rotate Z</span></button>
    <button class="button" style="vertical-align:middle" id = "ButtonT"><span>Toggle Rotation</span></button>
    <br>
    <div><p>Phong shading (per-fragment) :</p>
    <label class="switch">
      <input type="checkbox">
      <div class="slider round" id = "ButtonShading"></div>
    </label>
    </div>
    <br>
    <button class="button" style="vertical-align:middle; background-color: #008000" id = "ButtonPositionalLight"><span>Positional Light</span></button>
    <button class="button" style="vertical-align:middle; background-color: #008000" id = "ButtonDirectionalLight"><span>Directional Light</span></button>
    <button class="button" style="vertical-align:middle; background-color: #008000" id = "ButtonSpotlightLight"><span>Spotlight Light</span></button>


    <script id="vertex-shader" type="x-shader/x-vertex">

    precision mediump float;


    attribute  vec4 vPosition;
    attribute  vec4 vColor;
    attribute  vec2 vTexCoord;

    varying vec4 fColor;
    varying vec2 fTexCoord;

    varying vec3 N_for_frag;
    varying vec3 E_for_frag;
    varying vec3 L_positional_for_frag;
    varying vec3 D_for_frag; //directional light unit vector
    varying vec3 L_spotlight_for_frag;

    //declarations

    attribute vec3 vNormal;

    vec4 ambient, diffuse, specular;

    uniform vec4 positionalAmbientProduct;
    uniform vec4 positionalDiffuseProduct;
    uniform vec4 positionalSpecularProduct;
    uniform vec4 positionalLightPosition;


    uniform vec4 directionalAmbientProduct;
    uniform vec4 directionalSpecularProduct;
    uniform vec4 directionalDiffuseProduct;
    uniform vec4 directionalLightPosition;


    uniform vec4 spotlightAmbientProduct;
    uniform vec4 spotlightSpecularProduct;
    uniform vec4 spotlightDiffuseProduct;
    uniform vec4 spotlightLightPosition;


    uniform float shininess;

    uniform bool flagChangeShading;
    uniform bool flagPositionalLight;
    uniform bool flagDirectionalLight;
    uniform bool flagSpotlightLight;

    uniform mat4 projectionMatrix;
    uniform mat4 modelViewMatrix;


    void main()
    {

    if(flagChangeShading) {
        //pos = vector from the vertex towards the eye
        vec3 pos = -(modelViewMatrix * vPosition).xyz;
        //E= vector from the eye towards the vertex
        vec3 E = normalize(-pos);
        vec4 NN = vec4(vNormal,0);
        vec3 N = normalize((modelViewMatrix * NN).xyz);

    //GOUROUD
        //POSITIONAL LIGHT
        vec3 positionalLight = positionalLightPosition.xyz;
        vec3 L_positional = normalize(positionalLight - pos);
        vec3 H_positional = normalize(L_positional + E);

        vec4 positional_ambient = positionalAmbientProduct;
        float Kd1 = max(dot(L_positional, N), 0.0);
        vec4  positional_diffuse = Kd1 * positionalDiffuseProduct;
        float Ks1 = pow(max(dot(N, H_positional), 0.0), shininess);
        vec4  positional_specular = Ks1 * positionalSpecularProduct;
        if (dot(L_positional, N) < 0.0) {
            positional_specular = vec4(0.0, 0.0, 0.0, 1.0);
        }


        vec4 positionalColor = (positional_ambient + positional_diffuse + positional_specular);

        //DIRECTIONAL LIGHT
        //computing the unit direction toward the light
        vec3 D =  -normalize(directionalLightPosition.xyz);
        vec3 H_directional = normalize( D + E); 
        vec4 directional_ambient = directionalAmbientProduct;
        float Kd2 = max(dot(D, N), 0.0);
        vec4 directional_diffuse = Kd2 * directionalDiffuseProduct;
        float Ks2 =  pow(max(dot(N, H_directional), 0.0), shininess);
        vec4  directional_specular = Ks2 * directionalSpecularProduct;
        if (dot(D, N) < 0.0) {
            directional_specular = vec4(0.0, 0.0, 0.0, 1.0);
        }
        vec4 directionalColor = (directional_ambient + directional_diffuse + directional_specular);

        //FINALLY

        vec4 finalColor= vec4(0.0,0.0,0.0,0.0);
        if(flagPositionalLight){
            finalColor= finalColor + positionalColor;
        }
        if(flagDirectionalLight){
            finalColor= finalColor + directionalColor;
        }
        //SAME FOR SPOTLIGHT CONTRIBUTION
       
       finalColor.a=1.0;
        fColor= finalColor * vColor;


        fTexCoord = vTexCoord;
        gl_Position = projectionMatrix * modelViewMatrix * vPosition;
        gl_Position.z = -gl_Position.z;

        }
        else{
    //PHONG
            //check for duplicated code between if branches
            //POSITIONAL LIGHT
            vec3 pos = -(modelViewMatrix * vPosition).xyz;                  //duplicated
            vec3 positionalLight = positionalLightPosition.xyz;             //duplicated
            L_positional_for_frag =  normalize(positionalLight - pos);
            E_for_frag =  -pos; //maybe it should be normalized
            vec4 NN = vec4(vNormal,0);                                     //semi- duplicated
            N_for_frag = normalize((modelViewMatrix * NN).xyz);
            
            fColor= vColor;

            //DIRECTIONAL LIGHT
            D_for_frag=  -normalize(directionalLightPosition.xyz);
            //LIGHT INDEPENDANTS
            gl_Position = projectionMatrix * modelViewMatrix * vPosition;
            gl_Position.z = -gl_Position.z;
            fTexCoord = vTexCoord;
        };
    }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">

    precision mediump float;

    varying vec4 fColor;
    varying  vec2 fTexCoord;
    uniform bool flagChangeShading;


    uniform bool flagPositionalLight;
    uniform bool flagDirectionalLight;
    uniform bool flagSpotlightLight;


    uniform sampler2D Tex0;
    uniform sampler2D Tex1;

    uniform vec4 positionalAmbientProduct;
    uniform vec4 positionalDiffuseProduct;
    uniform vec4 positionalSpecularProduct;

    uniform vec4 directionalAmbientProduct;
    uniform vec4 directionalSpecularProduct;
    uniform vec4 directionalDiffuseProduct;

    uniform vec4 spotlightAmbientProduct;
    uniform vec4 spotlightSpecularProduct;
    uniform vec4 spotlightDiffuseProduct;

    uniform float shininess;

    varying vec3 N_for_frag;
    varying vec3 E_for_frag;
    varying vec3 L_positional_for_frag;
    varying vec3 D_for_frag; //directional light unit vector
    varying vec3 L_spotlight_for_frag;

    void
    main()
    {
        //GOUROUD
        if(flagChangeShading)   {
            gl_FragColor = fColor*(texture2D(Tex0, fTexCoord)*texture2D(Tex1, fTexCoord));
        }
        else{
        //PHONG
            //POSITIONAL LIGHT
            vec3 H_positional = normalize(L_positional_for_frag + E_for_frag);
            vec4 positional_ambient = positionalAmbientProduct;
            float Kd1 = max(dot(L_positional_for_frag, N_for_frag), 0.0);
            vec4  positional_diffuse = Kd1 * positionalDiffuseProduct;
            float Ks1 = pow(max(dot(N_for_frag, H_positional), 0.0), shininess);
            vec4  positional_specular = Ks1 * positionalSpecularProduct;
            if (dot(L_positional_for_frag, N_for_frag) < 0.0) {
                positional_specular = vec4(0.0, 0.0, 0.0, 1.0);
                }

            vec4 positionalColor = (positional_ambient + positional_diffuse + positional_specular);
            //DIRECTIONAL LIGHT
            vec3 H_directional = normalize( D_for_frag + E_for_frag);
            vec4 directional_ambient= directionalAmbientProduct;
            float Kd2 = max(dot(D_for_frag, N_for_frag), 0.0);
            vec4 directional_diffuse = Kd2 * directionalDiffuseProduct;
            float Ks2 =  pow(max(dot(N_for_frag, H_directional), 0.0), shininess);
            vec4  directional_specular = Ks2 * directionalSpecularProduct;
            if (dot(D_for_frag, N_for_frag) < 0.0) {
                directional_specular = vec4(0.0, 0.0, 0.0, 1.0);
            }

            vec4 directionalColor = (directional_ambient + directional_diffuse + directional_specular);
            //FINALLY
            vec4 finalColor= vec4(0.0,0.0,0.0,1.0);
            if(flagPositionalLight)
                finalColor= finalColor + positionalColor;
            if(flagDirectionalLight)
                finalColor= finalColor + directionalColor;
            //SAME FOR SPOTLIGHT CONTRIBUTION
            finalColor.a=1.0;

            gl_FragColor = (finalColor * fColor) * (texture2D(Tex0, fTexCoord)*texture2D(Tex1, fTexCoord));

        };
    }
    </script>

    <script type="text/javascript" src="../Common/webgl-utils.js"></script>
    <script type="text/javascript" src="../Common/initShaders.js"></script>
    <script type="text/javascript" src="../Common/MV.js"></script>
    <script type="text/javascript" src="new_version1616301.js"></script>

    <body>
    <canvas id="gl-canvas" width="1024" height="1024">
    Oops ... your browser doesn't support the HTML5 canvas element
    </canvas>
    </body>
    </html>
