    <!DOCTYPE html>
    <html>
    <head>
<style>
.button {
  display: inline-block;
  border-radius: 2px;
  background-color: #0066ff;
  border: none;
  color: #FFFFFF;
  text-align: center;
  font-size: 10px;
  padding: 6px;
  width: 120px;
  transition: all 0.1s;
  cursor: pointer;
  margin: 1px;
}

.button span {
  cursor: pointer;
  display: inline-block;
  position: relative;
  transition: 0.5s;
}

.button span:after {
  content: '\00bb';
  position: absolute;
  opacity: 0;
  top: 0;
  right: -20px;
  transition: 0.5s;
}

.button:hover span {
  padding-right: 25px;
}

.button:hover span:after {
  opacity: 1;
  right: 0;
}

.switch {
  position: relative;
  display: inline-block;
  width: 60px;
  height: 34px;
}

.switch input {display:none;}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  -webkit-transition: .4s;
  transition: .4s;
}

.slider:before {
  position: absolute;
  content: "";
  height: 26px;
  width: 26px;
  left: 4px;
  bottom: 4px;
  background-color: white;
  -webkit-transition: .4s;
  transition: .4s;
}

input:checked + .slider {
  background-color: #2196F3;
}

input:focus + .slider {
  box-shadow: 0 0 1px #2196F3;
}

input:checked + .slider:before {
  -webkit-transform: translateX(26px);
  -ms-transform: translateX(26px);
  transform: translateX(26px);
}

/* Rounded sliders */
.slider.round {
  border-radius: 34px;
}

.slider.round:before {
  border-radius: 50%;
}


</style>
</head>

 
    <button class="button" style="vertical-align:middle" id = "ButtonX"><span>Rotate X</span></button>
    <button class="button" style="vertical-align:middle" id = "ButtonY"><span>Rotate Y</span></button>
    <button class="button" style="vertical-align:middle" id = "ButtonZ"><span>Rotate Z</span></button>
    <button class="button" style="vertical-align:middle" id = "ButtonT"><span>Toggle Rotation</span></button>
    <button class="button" style="vertical-align:middle; background-color: #008000" id = "ButtonPositionalLight"><span>Positional Light</span></button>
    <button class="button" style="vertical-align:middle; background-color: #008000" id = "ButtonDirectionalLight"><span>Directional Light</span></button>
    <button class="button" style="vertical-align:middle; background-color: #008000" id = "ButtonSpotlightLight"><span>Spotlight Light</span></button>


    <br>
    <div><p>Phong shading (per-fragment) :</p>
    <label class="switch">
      <input type="checkbox">
      <div class="slider round" id = "ButtonShading"></div>
    </label>
    </div>
    <br>
    
    <script id="vertex-shader" type="x-shader/x-vertex">

    precision mediump float;

    attribute  vec4 vPosition;
    attribute  vec4 vColor;
    attribute  vec2 vTexCoord;

    varying vec4 fColor;
    varying vec2 fTexCoord;

    varying vec3 N_for_frag;
    varying vec3 E_for_frag;
    varying vec3 L_positional_for_frag;
    varying vec3 D_for_frag; //directional light unit vector
    varying vec3 L_spotlight_for_frag;

    attribute vec3 vNormal;

    vec4 ambient, diffuse, specular;

    uniform vec4 positionalAmbientProduct;
    uniform vec4 positionalDiffuseProduct;
    uniform vec4 positionalSpecularProduct;
    uniform vec4 positionalLightPosition;


    uniform vec4 directionalAmbientProduct;
    uniform vec4 directionalSpecularProduct;
    uniform vec4 directionalDiffuseProduct;
    uniform vec4 directionalLightPosition;


    uniform vec4 spotlightAmbientProduct;
    uniform vec4 spotlightSpecularProduct;
    uniform vec4 spotlightDiffuseProduct;
    uniform vec4 spotlightLightPosition;


    uniform vec3 spotlight_coneDirection;
    uniform float spotlight_thetaCone;
    uniform float spotlight_cutOff;

    uniform float shininess;

    uniform bool flagChangeShading;
    uniform bool flagPositionalLight;
    uniform bool flagDirectionalLight;
    uniform bool flagSpotlightLight;

    uniform mat4 projectionMatrix;
    uniform mat4 modelViewMatrix;


    void main()
    {
        //pos = vector from the eye towards the vertex (counter-intuitive
        vec3 pos = -(modelViewMatrix * vPosition).xyz;

    if(flagChangeShading) {
        
        //E= vector from the vertex towards the eye
        vec3 E = normalize(-pos);
        vec4 NN = vec4(vNormal,0);
        vec3 N = normalize((modelViewMatrix * NN).xyz);

    //GOUROUD
        //POSITIONAL LIGHT
        vec3 positionalLight = positionalLightPosition.xyz;
        vec3 L_positional = normalize(positionalLight - pos);
        vec3 H_positional = normalize(L_positional + E);

        vec4 positional_ambient = positionalAmbientProduct;
        float Kd1 = max(dot(L_positional, N), 0.0);
        vec4  positional_diffuse = Kd1 * positionalDiffuseProduct;
        float Ks1 = pow(max(dot(N, H_positional), 0.0), shininess);
        vec4  positional_specular = Ks1 * positionalSpecularProduct;
        if (dot(L_positional, N) < 0.0) {
            positional_specular = vec4(0.0, 0.0, 0.0, 1.0);
        }
        //  IMPLEMENT ATTENUATION
        vec4 positionalColor = (positional_ambient + positional_diffuse + positional_specular);

        //DIRECTIONAL LIGHT
        //computing the unit direction toward the light
        vec3 D =  normalize(directionalLightPosition.xyz);
        vec3 H_directional = normalize( D + E); 
        vec4 directional_ambient = directionalAmbientProduct;
        float Kd2 = max(dot(D, N), 0.0);
        vec4 directional_diffuse = Kd2 * directionalDiffuseProduct;
        float Ks2 =  pow(max(dot(N, H_directional), 0.0), shininess);
        vec4  directional_specular = Ks2 * directionalSpecularProduct;
        if (dot(D, N) < 0.0) {
            directional_specular = vec4(0.0, 0.0, 0.0, 1.0);
        }
        vec4 directionalColor = (directional_ambient + directional_diffuse + directional_specular);

        //SPOTLIGHT
        vec3 spotLightLight = spotlightLightPosition.xyz;
        vec3 L_spotlight = normalize(spotLightLight - pos);

        float spotlight_intensity_multiplier;
        vec3 C= normalize(spotlight_coneDirection);
        //s= vector from the spotlight source towards the surface
        vec3 s= -L_spotlight;
        //check if the cone direction and the direction towards the surface point are concordant
        if (dot(s,C) <= 0.0) {
            spotlight_intensity_multiplier =0.0;
        }
        else{
            float phi_angle= acos(dot(s,C));
            // check if the surface point is outside the cone of projected light
            if(degrees(phi_angle) > spotlight_thetaCone){
                spotlight_intensity_multiplier = 0.0;
            }
            else{
                spotlight_intensity_multiplier= pow(cos(phi_angle), spotlight_cutOff);
            }
        }
        // computing vectors with the emmbedded intensity of the spotlight
        vec3 L_spotlight_prime= L_spotlight* spotlight_intensity_multiplier;
        vec3 H_spotlight_prime= normalize(L_spotlight_prime + E);
        

        vec4 spotlight_ambient= spotlightAmbientProduct;
        float Kd3 = max(dot(L_spotlight_prime, N), 0.0);
        vec4  spotlight_diffuse = Kd3 * spotlightDiffuseProduct;
        float Ks3 = pow(max(dot(N, H_spotlight_prime), 0.0), shininess);
        vec4  spotlight_specular = Ks3 * spotlightSpecularProduct;
        if (dot(L_spotlight_prime, N) < 0.0) {
            spotlight_specular = vec4(0.0, 0.0, 0.0, 1.0);
        }
        vec4 spotlightColor = (spotlight_ambient + spotlight_diffuse + spotlight_specular);
        //  IMPLEMENT ATTENUATION

        //FINALLY

        vec4 finalColor= vec4(0.0,0.0,0.0,0.0);
        if(flagPositionalLight){
            finalColor= finalColor + positionalColor;
        }
        if(flagDirectionalLight){
            finalColor= finalColor + directionalColor;
        }
        if(flagSpotlightLight){
            finalColor= finalColor + spotlightColor;
        }

        finalColor.a=1.0;
        //  IMPLEMENT GAMMA CORRECTION
        fColor= finalColor * vColor;


        fTexCoord = vTexCoord;
        gl_Position = projectionMatrix * modelViewMatrix * vPosition;
        gl_Position.z = -gl_Position.z;

        }
        else{
        //PHONG
            //check for duplicated code between if branches
            //POSITIONAL LIGHT
            vec3 positionalLight = positionalLightPosition.xyz;             
            L_positional_for_frag =  normalize(positionalLight - pos);
            E_for_frag =  -pos; //maybe it should be normalized
            vec4 NN = vec4(vNormal,0);                              
            N_for_frag = normalize((modelViewMatrix * NN).xyz);
            
            fColor= vColor;

            //DIRECTIONAL LIGHT
            D_for_frag=  -normalize(directionalLightPosition.xyz);

            //SPOTLIGHT
            vec3 spotLightLight = spotlightLightPosition.xyz;
            L_spotlight_for_frag= normalize( spotLightLight - pos);

            //LIGHT INDEPENDANTS
            gl_Position = projectionMatrix * modelViewMatrix * vPosition;
            gl_Position.z = -gl_Position.z;
            fTexCoord = vTexCoord;
        };
    }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">

    precision mediump float;

    varying vec4 fColor;
    varying  vec2 fTexCoord;
    uniform bool flagChangeShading;


    uniform bool flagPositionalLight;
    uniform bool flagDirectionalLight;
    uniform bool flagSpotlightLight;


    uniform sampler2D Tex0;
    uniform sampler2D Tex1;

    uniform vec4 positionalAmbientProduct;
    uniform vec4 positionalDiffuseProduct;
    uniform vec4 positionalSpecularProduct;

    uniform vec4 directionalAmbientProduct;
    uniform vec4 directionalSpecularProduct;
    uniform vec4 directionalDiffuseProduct;

    uniform vec4 spotlightAmbientProduct;
    uniform vec4 spotlightSpecularProduct;
    uniform vec4 spotlightDiffuseProduct;


    uniform vec3 spotlight_coneDirection;
    uniform float spotlight_thetaCone;
    uniform float spotlight_cutOff;

    uniform float shininess;

    varying vec3 N_for_frag;
    varying vec3 E_for_frag;
    varying vec3 L_positional_for_frag;
    varying vec3 D_for_frag; //directional light unit vector
    varying vec3 L_spotlight_for_frag;

    void
    main()
    {
        //GOUROUD
        if(flagChangeShading)   {
            gl_FragColor = fColor*(texture2D(Tex0, fTexCoord)*texture2D(Tex1, fTexCoord));
        }
        else{
        //PHONG
            //POSITIONAL LIGHT
            vec3 H_positional = normalize(L_positional_for_frag + E_for_frag);
            vec4 positional_ambient = positionalAmbientProduct;
            float Kd1 = max(dot(L_positional_for_frag, N_for_frag), 0.0);
            vec4  positional_diffuse = Kd1 * positionalDiffuseProduct;
            float Ks1 = pow(max(dot(N_for_frag, H_positional), 0.0), shininess);
            vec4  positional_specular = Ks1 * positionalSpecularProduct;
            if (dot(L_positional_for_frag, N_for_frag) < 0.0) {
                positional_specular = vec4(0.0, 0.0, 0.0, 1.0);
            }
                    //  IMPLEMENT ATTENUATION
            vec4 positionalColor = (positional_ambient + positional_diffuse + positional_specular);
            //DIRECTIONAL LIGHT
            vec3 H_directional = normalize( D_for_frag + E_for_frag);
            vec4 directional_ambient= directionalAmbientProduct;
            float Kd2 = max(dot(D_for_frag, N_for_frag), 0.0);
            vec4 directional_diffuse = Kd2 * directionalDiffuseProduct;
            float Ks2 =  pow(max(dot(N_for_frag, H_directional), 0.0), shininess);
            vec4  directional_specular = Ks2 * directionalSpecularProduct;
            if (dot(D_for_frag, N_for_frag) < 0.0) {
                directional_specular = vec4(0.0, 0.0, 0.0, 1.0);
            }

            vec4 directionalColor = (directional_ambient + directional_diffuse + directional_specular);


            //SPOTLIGHT

            float spotlight_intensity_multiplier;
            vec3 C= normalize(spotlight_coneDirection);
            //s= vector from the spotlight source towards the surface
            vec3 s= -L_spotlight_for_frag;
            //check if the cone direction and the direction towards the surface point are concordant
            if (dot(s,C) <= 0.0) {
                spotlight_intensity_multiplier =0.0;
            }
            else{
                float phi_angle= acos(dot(s,C));
                // check if the surface point is outside the cone of projected light
                if(degrees(phi_angle) > spotlight_thetaCone){
                   spotlight_intensity_multiplier = 0.0;
                }
                else{
                    spotlight_intensity_multiplier= pow(cos(phi_angle), spotlight_cutOff);
                }
            }
            // computing vectors with the emmbedded intensity of the spotlight (! not normalized in order to preserve the intensity information)
            vec3 L_spotlight_for_frag_prime= L_spotlight_for_frag * spotlight_intensity_multiplier;

            vec3 H_spotlight_prime = normalize(L_spotlight_for_frag_prime + E_for_frag);
            vec4 spotlight_ambient = spotlightAmbientProduct;
            float Kd3 = max(dot(L_spotlight_for_frag_prime, N_for_frag), 0.0);
            vec4  spotlight_diffuse = Kd3 * spotlightDiffuseProduct;
            float Ks3 = pow(max(dot(N_for_frag, H_spotlight_prime), 0.0), shininess);
            vec4  spotlight_specular = Ks3 * spotlightSpecularProduct;
            if (dot(L_spotlight_for_frag_prime, N_for_frag) < 0.0) {
                spotlight_specular = vec4(0.0, 0.0, 0.0, 1.0);
            }

            vec4 spotlightColor = (spotlight_ambient + spotlight_diffuse + spotlight_specular);
                    //  IMPLEMENT ATTENUATION

            //FINALLY
            vec4 finalColor= vec4(0.0,0.0,0.0,1.0);
            if(flagPositionalLight){
                finalColor= finalColor + positionalColor;
            }
            if(flagDirectionalLight){
                finalColor= finalColor + directionalColor;
            }
             if(flagSpotlightLight){
            finalColor= finalColor + spotlightColor;
            }

            finalColor.a=1.0;
            // IMPLEMENT GAMMA CORRECTION
            gl_FragColor = (finalColor * fColor) * (texture2D(Tex0, fTexCoord)*texture2D(Tex1, fTexCoord));

        };
    }
    </script>

    <script type="text/javascript" src="../Common/webgl-utils.js"></script>
    <script type="text/javascript" src="../Common/initShaders.js"></script>
    <script type="text/javascript" src="../Common/MV.js"></script>
    <script type="text/javascript" src="new_version1616301.js"></script>

    <body>
    <canvas id="gl-canvas" width="1024" height="1024">
    Oops ... your browser doesn't support the HTML5 canvas element
    </canvas>
    </body>
    </html>
